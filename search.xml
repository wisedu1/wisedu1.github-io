<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java 基础</title>
    <url>/2021/04/30/Java%20%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-java-基础"><a href="#1-java-基础" class="headerlink" title="1 java 基础"></a>1 java 基础</h2><h3 id="1-1-容器"><a href="#1-1-容器" class="headerlink" title="1.1 容器"></a>1.1 容器</h3><h4 id="1-1-1-LinkedList-和-ArrayList"><a href="#1-1-1-LinkedList-和-ArrayList" class="headerlink" title="1.1.1 LinkedList 和 ArrayList"></a>1.1.1 LinkedList 和 ArrayList</h4><ol>
<li><p>数据结构不同</p>
<ul>
<li>ArrayList <font color ="red">（好查找）</font>是数组的数据结构。</li>
<li>LinkedList <font color="red">（好修改）</font>是链表的数据结构。</li>
</ul>
</li>
<li><p>效率不同</p>
<p>当随机访问 List（ get 和 set 操作）时，ArrayList 比 LinkedList 的效率更高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</p>
<p>当对数据进行增加和删除的操作( add 和 remove 操作)时，LinkedList 比 ArrayList  的效率更高，因为 ArrayList 是数组，所以在其中进行增删操作时，会对操作点之后所有数据的下标索引造成影响，需要进行数据的移动。</p>
</li>
<li><p>自由性不同</p>
<p>ArrayList 自由性较低，因为它需要<strong>手动</strong>的设置固定大小的容量，但是它的使用比较方便，只需要创建，然后添加数据，通过调用下标进行使用；而 LinkedList 自由性较高，能够动态的随数据量的变化而变化，但是它不便于使用。</p>
</li>
<li><p>主要控件开销不同</p>
<p>ArrayList 主要控件开销在于需要在给 ArrayList 列表预留一定空间；而 LinkedList 主要控件开销在于需要存储结点信息以及结点指针信息。</p>
</li>
<li><p>ArrayList 和 LinkedList 的线程安全问题</p>
<p>都不安全，不然不然 JUC 不会实现 CopyOnWriteArrayList 和 ConcurrentLinkedQueue。</p>
<blockquote>
<p>JUC: java.util.concurrent</p>
</blockquote>
</li>
</ol>
<h4 id="1-1-2-HashMap"><a href="#1-1-2-HashMap" class="headerlink" title="1.1.2 HashMap"></a>1.1.2 HashMap</h4><ol>
<li><p>HashMap 的数据结构</p>
<p>哈希结构表：数组+链表</p>
<ul>
<li><p><font color="red">通过哈希表结构配合对象的 hashCode 和 equals 方法就可以保证键的唯一性</font></p>
<blockquote>
<p>建议今后存储自定义类型的时候，重写hashCode和equals方法。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>HashMap 和 HashTable 以及 concurrentHashmap 的区别</p>
<ul>
<li><p>HashMap（不同步，<strong>线程不安全</strong>）允许存储null键和null值；</p>
</li>
<li><p>Hashtable 不允许存储 null 键和 null 值（同步，<strong>线程安全</strong>，<strong>效率低</strong>）。</p>
<blockquote>
<p>如果在多线程的场景下，也无需使用 Hashtable 集合，我们可以使用 <strong>ConcurrenntHashMap</strong> 集合，这是一个线程同步的。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>HashMap resize()</p>
<ul>
<li><p>两个重要参数：</p>
<ul>
<li><p><strong>初始容量</strong></p>
<p>默认 16</p>
<p>哈希表中桶的数量</p>
</li>
<li><p><strong>负载因子</strong></p>
<p>默认 0.75</p>
<p>哈希表扩容的阈值</p>
</li>
</ul>
</li>
<li><p>HashMap 的扩容</p>
<ul>
<li>当达到阈值时，自动扩容。</li>
<li>扩容后的数组为原数组的<strong>两倍</strong>，并且数组的大小是 <strong>2 的次幂</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p>Collection 与 Collections 的根本区别</p>
<ul>
<li>Collection 是一个<strong>集合接口</strong>。它提供了对集合对象进行基本操作的通用接口方法。Collection 接口在 Java 类库中有很多具体的实现。Collection 接口的意义是为各种具体的集合提供了最大化的统一操作方式。</li>
<li>Collections 是一个<strong>包装类</strong>。它包含有各种有关集合操作的<strong>静态多态</strong>方法。此类<strong>不能实例化</strong>，就像一个工具类，服务于Java的 Collection 框架。</li>
</ul>
</li>
</ol>
<h4 id="1-1-3-HashCode-和-equals"><a href="#1-1-3-HashCode-和-equals" class="headerlink" title="1.1.3 HashCode() 和 equals()"></a>1.1.3 HashCode() 和 equals()</h4><ol>
<li>它们都是 Object 类中的方法<ul>
<li>如果类不重写这两个方法：<ul>
<li>hashCode():属于是本地方法，返回的是对象的地址值。</li>
<li>equals():用来比较两个对象的地址值是否相等。</li>
</ul>
</li>
<li>如果重写这两个方法：<ul>
<li>hashCode(): 返回的是根据对象的成员变量，计算出的一个整数。</li>
<li>equals(): 比较的是两个对象中成员信息是否相等。</li>
</ul>
</li>
</ul>
</li>
<li>类中重写 hashCode() 和 equals() 比较两个对象是否相等<ul>
<li>两个对象通过 equals() 比较是相等的，那 hashCode() 肯定是相等，也就是 equals() 是绝对可靠的。</li>
<li>两个对象通过 hashCode 比较相等，但是equals去做比较不一定相等，也就是 hashCode 不是绝对可靠的。</li>
</ul>
</li>
<li>通过 hashCode 和 equals 搭配使用提高判断相等效率<ul>
<li>由于对于一个对象有大量的成员信息，用 equals 比较会降低效率，所以可以先通过 hashCode 进行比较，如果不相等则两个对象一定不同，如果相同再用 equals 比较，这样可以调高效率。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java 常见难点</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring MVC 框架总结</title>
    <url>/2021/04/27/Spring%20MVC%20%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="Spring-MVC-框架总结"><a href="#Spring-MVC-框架总结" class="headerlink" title="Spring MVC 框架总结"></a>Spring MVC 框架总结</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>最近开始接触 Spring MVC，但是零零散散，没有在大脑里形成系统的知识结构体系，于是在此进行了梳理。</p>
<h2 id="什么是-MVC"><a href="#什么是-MVC" class="headerlink" title="什么是 MVC"></a>什么是 MVC</h2><p>Spring MVC 是 Spring 框架的一个模块，Spring MVC 和 Spring 无需通过中间整合层进行整合。</p>
<p>Spring MVC 是一个基于 MVC 的 web 框架。</p>
<p><strong>MVC</strong> 模式是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：</p>
<ul>
<li>控制器(<strong>C</strong>ontroller)——负责转发请求，对请求进行处理。</li>
<li>视图 (<strong>V</strong>iew)——界面设计人员进行图形界面设计。</li>
<li>模型 (<strong>M</strong>odel)——程序员编写程序应有的功能、数据库专家进行数据管理和数据库设计。</li>
</ul>
<p>所以，MVC 模式将程序划分了三个组件，<strong>模型 (Model)</strong> 用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法。<strong>视图 (View)</strong> 负责展示数据，<strong>控制器 (Contoller)</strong> 处理事件并作出响应（事件包括用户的行为，比如请求）和数据 Model 上的改变。</p>
<ul>
<li>用户发起 request 请求至控制器 (Controller)，控制器接收用户请求的数据，委托给模型进行处理</li>
<li>控制器通过模型处理数据并得到处理结果，模型通常是指业务逻辑</li>
<li>模型处理结果返回给控制器</li>
<li>控制器将模型数据在视图中展示，web 中模型无法将数据直接在视图上显示，需要通过控制器完成</li>
<li>控制器将视图 response 响应给用户，通过视图展示给用户要的数据或处理结果</li>
</ul>
<h2 id="Spring-MVC-核心架构"><a href="#Spring-MVC-核心架构" class="headerlink" title="Spring MVC 核心架构"></a>Spring MVC 核心架构</h2><p><img src="https://gitee.com/wisedu1/MyImage/raw/master/imgs/%E6%A1%86%E6%9E%B6/SpringMVC%20%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg"></p>
<ol>
<li>用户发起请求到前端控制器 (DispatcherServlet)</li>
<li>前端控制器请求处理器映射器 HandlerMapping 查找 Handler，可以根据 xml 配置、注解进行查找</li>
<li>处理器映射器 HandlerMapping 向前端控制器返回 Handler</li>
<li>前端控制器调用处理器适配器 HandlerAdapter 去执行 Handler</li>
<li>处理器适配器去执行 Handler</li>
<li>处理器适配器向前端控制器返回 ModelAndView，它是 Spirng MVC 框架的一个底层对象，包括 Model 和 View</li>
<li>前端控制器请求视图解析器 ViewResolver 去进行视图解析，根据逻辑视图名解析成真正的视图</li>
<li>视图解析器 向前端控制器返回 View</li>
<li>前端控制器进行视图渲染，视图渲染将模型数据（在 ModelAndView 对象中）填充到 request 域</li>
<li>前端控制器向用户响应结果</li>
</ol>
<p>通常，一个项目是由 Spring + SpringMVC + MyBatis 三大框架整合的 SSM 框架完成。</p>
<h2 id="Spring-MVC-常用注解"><a href="#Spring-MVC-常用注解" class="headerlink" title="Spring MVC 常用注解"></a>Spring MVC 常用注解</h2><ol>
<li><p>@Controller</p>
<p>负责注册一个 bean 到 Spring Context中。</p>
</li>
<li><p>@RequstMapping</p>
<p>注解为控制器指定可以处理那些 URL 请求。</p>
</li>
<li><p>@RequstBody</p>
<p>该注解用于读取 <code>Request</code> 请求的 body 部分数据，使用系统默认配置的 <code>HttpMessageConverter</code> 进行解析，然后把响应的数据绑定到要返回的对象上，再把 <code>HttpMessageConverter</code> 返回的对象数据绑定到 controller 中方法的参数上。</p>
</li>
<li><p>@ResponseBody</p>
<p>该注解用于将 controller 的方法返回的对象通过适当的 <code>HttpMessageConverter</code> 转换成为指定格式后，写入到 <code>Response</code> 对象的 body 数据区。</p>
</li>
<li><p>@ModelAttribute</p>
<p>在方法定义上使用 @ModelAttribute 注解：Spring MVC 在调用目标处理方法前，会先逐个调用在方法级上标注了 @ModelAttribute 的方法。</p>
<p>在方法的入参前使用 @ModelAttribute 注解：可以从隐含对象中获取隐含的模型数据中获取对象，再将请求参数绑定到对象中，再传入入参将方法入参对象添加到模型中。</p>
</li>
<li><p>@RequstParam</p>
<p>在处理方法入参处使用 @RequestParam 可以把请求参数传递给请求方法。</p>
</li>
<li><p>@PathVariable</p>
<p>绑定 URL 占位符到入参。</p>
</li>
<li><p>@ExceptionHandler</p>
<p>注解到方法上，出现异常时会执行该方法。</p>
</li>
<li><p>@ControllerAdvice</p>
<p>使一个 Controller 成为全局的异常处理类，类中使用 @ExceptionHandler 注解的方法可以处理所有 Controller 发生的异常。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 框架常见问题</title>
    <url>/2021/04/28/Spring%20%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="Spring-框架常见问题"><a href="#Spring-框架常见问题" class="headerlink" title="Spring 框架常见问题"></a>Spring 框架常见问题</h1><h2 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1 基础概念"></a>1 基础概念</h2><h3 id="1-1-什么是-Spring-Framewoks？"><a href="#1-1-什么是-Spring-Framewoks？" class="headerlink" title="1.1 什么是 Spring Framewoks？"></a>1.1 什么是 Spring Framewoks？</h3><p>Spring 是一个开源应用框架，旨在降低应用程序开发的复杂度。</p>
<p>它是轻量级、松散耦合的。</p>
<p>它具有分层体系结构，允许用户选择组件，同时还为<code>J2EE</code>应用程序开发提供了一个有凝聚力的框架。</p>
<p>它可以集成其他框架，如 Structs、Hibernate、EJB 等，所以又称为<strong>框架的框架</strong>。</p>
<h3 id="1-2-Spring-Framework-的优点有哪些？"><a href="#1-2-Spring-Framework-的优点有哪些？" class="headerlink" title="1.2  Spring Framework 的优点有哪些？"></a>1.2  Spring Framework 的优点有哪些？</h3><p>由于 Spring Frameworks 的分层架构，用户可以自由选择自己需要的组件。</p>
<p>Spring Framework 支持 **POJO (Plain Old Java Object) **编程，从而具备持续集成和可测试性。</p>
<p>由于依赖注入和控制反转，JDBC 得以简化。</p>
<p>它是开源免费的。</p>
<h3 id="1-3-Spinrg-Framework-有哪些不同的功能？"><a href="#1-3-Spinrg-Framework-有哪些不同的功能？" class="headerlink" title="1.3 Spinrg Framework 有哪些不同的功能？"></a>1.3 Spinrg Framework 有哪些不同的功能？</h3><p>轻量级 - Spring 在代码量和透明度方面都很轻便。</p>
<p>IOC - 控制反转</p>
<p>AOP - 面向切面编程可以将应用业务逻辑和系统服务分离，以实现高内聚。</p>
<p>容器 - Spring 负责创建和管理对象（Bean）的生命周期和配置。</p>
<p>MVC - 对 web 应用提供了高度可配置性，其他框架的集成也十分方便。</p>
<p>事务管理 - 提供了用于事务管理的通用抽象层。Spring 的事务支持也可用于容器较少的环境。</p>
<p>JDBC 异常 - Spring 的 JDBC 抽象层提供了一个异常层次结构，简化了错误处理策略。</p>
<h3 id="1-4-Spring-Framework-中有多少个模块，它们分别是什么？"><a href="#1-4-Spring-Framework-中有多少个模块，它们分别是什么？" class="headerlink" title="1.4 Spring Framework 中有多少个模块，它们分别是什么？"></a>1.4 Spring Framework 中有多少个模块，它们分别是什么？</h3><p><img src="https://gitee.com/wisedu1/MyImage/raw/master/imgs/%E6%A1%86%E6%9E%B6/Spring%20Framework%20Runtime.png"></p>
<p><strong>Spring 核心容器 – 该层基本上是 Spring Framework 的核心。它包含以下模块：</strong></p>
<ul>
<li>Spring Core</li>
<li>Spring Bean</li>
<li>SpEL (Spring Expression Language)</li>
<li>Spring Context</li>
</ul>
<p><strong>数据访问/集成 – 该层提供与数据库交互的支持。它包含以下模块：</strong></p>
<ul>
<li>JDBC (Java DataBase Connectivity)</li>
<li>ORM (Object Relational Mapping)</li>
<li>OXM (Object XML Mappers)</li>
<li>JMS (Java Messaging Service)</li>
<li>Transaction</li>
</ul>
<p><strong>Web – 该层提供了创建 Web 应用程序的支持。它包含以下模块：</strong></p>
<ul>
<li>Web</li>
<li>Web – Servlet</li>
<li>Web – Socket</li>
<li>Web – Portlet</li>
</ul>
<p><strong>AOP – 该层支持面向切面编程。</strong></p>
<p><strong>Instrumentation – 该层为类检测和类加载器实现提供支持。</strong></p>
<p><strong>Test – 该层为使用 JUnit 和 TestNG 进行测试提供支持。</strong></p>
<p><strong>几个杂项模块:</strong></p>
<ul>
<li>Messaging – 该模块为 STOMP 提供支持。它还支持注解编程模型，该模型用于从 WebSocket 客户端路由和处理 STOMP 消息</li>
<li>Aspects – 该模块为与 AspectJ 的集成提供支持。</li>
</ul>
<h3 id="1-5-什么是-Spring-配置文件？"><a href="#1-5-什么是-Spring-配置文件？" class="headerlink" title="1.5 什么是 Spring 配置文件？"></a>1.5 什么是 Spring 配置文件？</h3><p>Spring 配置文件是 XML 文件。该文件主要包含类信息。它描述了这些类是如何配置以及相互引入的。但是，XML 配置文件冗长且更加干净。如果没有正确规划和编写，那么在大项目中管理变得非常困难。</p>
<h3 id="1-6-Spring-应用程序有哪些不同组件？"><a href="#1-6-Spring-应用程序有哪些不同组件？" class="headerlink" title="1.6 Spring 应用程序有哪些不同组件？"></a>1.6 Spring 应用程序有哪些不同组件？</h3><p>Spring 应用一般有以下组件：</p>
<p><strong>接口</strong> - 定义功能。</p>
<p><strong>Bean 类</strong> - 它包含属性，setter 和 getter 方法，函数等。</p>
<p><strong>Spring 面向切面编程（AOP）</strong> - 提供面向切面编程的功能。</p>
<p><strong>Bean 配置文件</strong> - 包含类的信息以及如何配置它们。</p>
<p><strong>用户程序</strong> - 它使用接口。</p>
<h3 id="1-7-使用-Spring-有哪些方式？"><a href="#1-7-使用-Spring-有哪些方式？" class="headerlink" title="1.7 使用 Spring 有哪些方式？"></a>1.7 使用 Spring 有哪些方式？</h3><p>使用 Spring 有以下方式：</p>
<ul>
<li>作为一个成熟的 Spring Web 应用程序。</li>
<li>作为第三方 Web 框架，使用 Spring Frameworks 中间层。</li>
<li>用于远程使用。</li>
<li>作为企业级 Java Bean，它可以包装现有的 POJO（Plain Old Java Objects）。</li>
</ul>
<h2 id="2-依赖注入（Ioc）"><a href="#2-依赖注入（Ioc）" class="headerlink" title="2 依赖注入（Ioc）"></a>2 依赖注入（Ioc）</h2><h3 id="2-1-什么是-Spring-IOC-容器？"><a href="#2-1-什么是-Spring-IOC-容器？" class="headerlink" title="2.1 什么是 Spring IOC 容器？"></a>2.1 什么是 Spring IOC 容器？</h3><p>Spring 框架的核心是 Spring 容器。容器创建对象，将它们装配在一起，配置它们并管理它们的完整生命周期。Spring 容器使用依赖注入来管理组成应用程序的组件。</p>
<p>容器通过读取提供的配置元数据来接收对象进行实例化，配置和组装的指令。该元数据可以通过 XML，Java 注解或 Java 代码提供。</p>
<p><img src="https://gitee.com/wisedu1/MyImage/raw/master/imgs/%E6%A1%86%E6%9E%B6/Spring%20container.png"></p>
<h3 id="2-2-什么是依赖注入？"><a href="#2-2-什么是依赖注入？" class="headerlink" title="2.2 什么是依赖注入？"></a>2.2 什么是依赖注入？</h3><p>在依赖注入中，您不必创建对象，但必须描述如何创建它们。您不是直接在代码中将组件和服务连接在一起，而是描述配置文件中哪些组件需要哪些服务。由 IoC 容器将它们装配在一起。</p>
<h3 id="2-3-可以通过多少种方式完成依赖注入？"><a href="#2-3-可以通过多少种方式完成依赖注入？" class="headerlink" title="2.3 可以通过多少种方式完成依赖注入？"></a>2.3 可以通过多少种方式完成依赖注入？</h3><p>通常，依赖注入可以通过三种方式完成，即：</p>
<ul>
<li>构造函数注入</li>
<li>setter 注入</li>
<li>接口注入</li>
</ul>
<p>在 Spring Framework 中，仅使用构造函数和 setter 注入。</p>
<h3 id="2-4-区分构造函数注入和-setter-注入"><a href="#2-4-区分构造函数注入和-setter-注入" class="headerlink" title="2.4 区分构造函数注入和 setter 注入"></a>2.4 区分构造函数注入和 setter 注入</h3><p><img src="https://gitee.com/wisedu1/MyImage/raw/master/imgs/%E6%A1%86%E6%9E%B6/%E5%8C%BA%E5%88%86%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%B3%A8%E5%85%A5%E5%92%8Csetter%E6%B3%A8%E5%85%A5.png"></p>
<h3 id="2-5-spring-中有多少种-IOC-容器？"><a href="#2-5-spring-中有多少种-IOC-容器？" class="headerlink" title="2.5 spring 中有多少种 IOC 容器？"></a>2.5 spring 中有多少种 IOC 容器？</h3><ul>
<li>BeanFactory - BeanFactory 就像一个包含 bean 集合的工厂类。它会在客户端要求时实例化 bean。</li>
<li>ApplicationContext - ApplicationContext 接口扩展了 BeanFactory 接口。它在 BeanFactory 基础上提供了一些额外的功能。</li>
</ul>
<h3 id="2-6-区分-BeanFactory-和-ApplicationContext"><a href="#2-6-区分-BeanFactory-和-ApplicationContext" class="headerlink" title="2.6 区分 BeanFactory 和 ApplicationContext"></a>2.6 区分 BeanFactory 和 ApplicationContext</h3><p><img src="https://gitee.com/wisedu1/MyImage/raw/master/imgs/%E6%A1%86%E6%9E%B6/%E5%8C%BA%E5%88%86BeanFactory%E5%92%8CApplicationContext.png"></p>
<h3 id="2-7-IoC-的一些好处"><a href="#2-7-IoC-的一些好处" class="headerlink" title="2.7 IoC 的一些好处"></a>2.7 IoC 的一些好处</h3><p>IoC 的一些好处是：</p>
<ul>
<li>它将最小化应用程序中的代码量。</li>
<li>它将使您的应用程序易于测试，因为它不需要单元测试用例中的任何单例或 JNDI 查找机制。</li>
<li>它以最小的影响和最少的侵入机制促进松耦合。</li>
<li>它支持即时的实例化和延迟加载服务。</li>
</ul>
<h3 id="2-8-Spring-IoC-的实现机制"><a href="#2-8-Spring-IoC-的实现机制" class="headerlink" title="2.8 Spring IoC 的实现机制"></a>2.8 Spring IoC 的实现机制</h3><p>Spring 中的 IoC 的实现原理就是<strong>工厂模式</strong>加<strong>反射机制</strong>。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Orange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title">getInstance</span><span class="params">(String ClassName)</span> </span>&#123;</span><br><span class="line">        Fruit f=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            f=(Fruit)Class.forName(ClassName).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] a)</span> </span>&#123;</span><br><span class="line">        Fruit f=Factory.getInstance(<span class="string">&quot;io.github.dunwu.spring.Apple&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(f!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            f.eat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-Beans"><a href="#3-Beans" class="headerlink" title="3 Beans"></a>3 Beans</h2><h3 id="3-1-什么是-spring-bean？"><a href="#3-1-什么是-spring-bean？" class="headerlink" title="3.1 什么是 spring bean？"></a>3.1 什么是 spring bean？</h3><ul>
<li>它们是构成用户应用程序主干的对象。</li>
<li>Bean 由 Spring IoC 容器管理。</li>
<li>它们由 Spring IoC 容器实例化，配置，装配和管理。</li>
<li>Bean 是基于用户提供给容器的配置元数据创建。</li>
</ul>
<h3 id="3-2-spring-提供了哪些配置方式？"><a href="#3-2-spring-提供了哪些配置方式？" class="headerlink" title="3.2 spring 提供了哪些配置方式？"></a>3.2 spring 提供了哪些配置方式？</h3><ul>
<li><strong>基于 xml 配置</strong></li>
</ul>
<p>bean 所需的依赖项和服务在 XML 格式的配置文件中指定。这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。它们通常以 bean 标签开头。例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;studentbean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.edureka.firstSpring.StudentBean&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Edureka&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>基于注解配置</strong></li>
</ul>
<p>您可以通过在相关的类，方法或字段声明上使用注解，将 bean 配置为组件类本身，而不是使用 XML 来描述 bean 装配。默认情况下，Spring 容器中未打开注解装配。因此，您需要在使用它之前在 Spring 配置文件中启用它。例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- bean definitions go here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>基于 Java API 配置</strong></li>
</ul>
<p>Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。</p>
<ol>
<li>@Bean 注解扮演与 <bean /> 元素相同的角色。</li>
<li>@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。</li>
</ol>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StudentBean <span class="title">myStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StudentBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-spring-支持集中-bean-scope？"><a href="#3-3-spring-支持集中-bean-scope？" class="headerlink" title="3.3 spring 支持集中 bean scope？"></a>3.3 spring 支持集中 bean scope？</h3><p>Spring bean 支持 5 种 scope：</p>
<ul>
<li>Singleton - 每个 Spring IoC 容器仅有一个单实例。</li>
<li>Prototype - 每次请求都会产生一个新的实例。</li>
<li>Request - 每一次 HTTP 请求都会产生一个新的实例，并且该 bean 仅在当前 HTTP 请求内有效。</li>
<li>Session - 每一次 HTTP 请求都会产生一个新的 bean，同时该 bean 仅在当前 HTTP session 内有效。</li>
<li>Global-session - 类似于标准的 HTTP Session 作用域，不过它仅仅在基于 portlet 的 web 应用中才有意义。Portlet 规范定义了全局 Session 的概念，它被所有构成某个 portlet web 应用的各种不同的 portlet 所共享。在 global session 作用域中定义的 bean 被限定于全局 portlet Session 的生命周期范围内。如果你在 web 中使用 global session 作用域来标识 bean，那么 web 会自动当成 session 类型来使用。</li>
</ul>
<p>仅当用户使用支持 Web 的 ApplicationContext 时，最后三个才可用。更多spring内容</p>
<h3 id="3-4-spring-bean-容器的生命周期是什么样的？"><a href="#3-4-spring-bean-容器的生命周期是什么样的？" class="headerlink" title="3.4 spring bean 容器的生命周期是什么样的？"></a>3.4 spring bean 容器的生命周期是什么样的？</h3><p>spring bean 容器的生命周期流程如下：</p>
<ol>
<li>Spring 容器根据配置中的 bean 定义中实例化 bean</li>
<li>Spring 使用依赖注入填充所有属性，如 bean 中所定义的配置。</li>
<li>如果 bean 实现 BeanNameAware 接口，则工厂通过传递 bean 的 ID 来调用 setBeanName()。</li>
<li>如果 bean 实现 BeanFactoryAware 接口，工厂通过传递自身的实例来调用 setBeanFactory()。</li>
<li>如果存在与 bean 关联的任何 BeanPostProcessors，则调用 preProcessBeforeInitialization() 方法。</li>
<li>如果为 bean 指定了 init 方法（ <bean>的 init-method 属性），那么将调用它。</li>
<li>最后，如果存在与 bean 关联的任何 BeanPostProcessors，则将调用 postProcessAfterInitialization() 方法。</li>
<li>如果 bean 实现 DisposableBean 接口，当 spring 容器关闭时，会调用 destory()。</li>
<li>如果为 bean 指定了 destroy 方法（ <bean>的 destroy-method 属性），那么将调用它。</li>
</ol>
<p><img src="https://gitee.com/wisedu1/MyImage/raw/master/imgs/%E6%A1%86%E6%9E%B6/Spring%20bean%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"></p>
<h3 id="3-5-什么是-spring-的内部-bean？"><a href="#3-5-什么是-spring-的内部-bean？" class="headerlink" title="3.5 什么是 spring 的内部 bean？"></a>3.5 什么是 spring 的内部 bean？</h3><p>只有将 bean 用作另一个 bean 的属性时，才能将 bean 声明为内部 bean。为了定义 bean，Spring 的基于 XML 的配置元数据在<property>或<constructor-arg> 中提供了<bean>元素的使用。内部 bean 总是匿名的，它们总是作为原型。</p>
<p>例如，假设我们有一个 Student 类，其中引用了 Person 类。这里我们将只创建一个 Person 类实例并在 Student 中使用它。</p>
<p>Student.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line">    <span class="comment">//Setters and Getters</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="comment">//Setters and Getters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bean.xml</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;bean id=“StudentBean<span class="string">&quot; class=&quot;</span>com.edureka.Student<span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;property name=&quot;</span>person<span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;!--This is inner bean --&gt;</span></span><br><span class="line"><span class="string">        &lt;bean class=&quot;</span>com.edureka.Person<span class="string">&quot;&gt;</span></span><br><span class="line">            &lt;property name=&quot;name&quot; value=“Scott&quot;&gt;&lt;/property&gt;</span><br><span class="line">            &lt;property name=<span class="string">&quot;address&quot;</span> value=“Bangalore<span class="string">&quot;&gt;&lt;/property&gt;</span></span><br><span class="line"><span class="string">        &lt;/bean&gt;</span></span><br><span class="line"><span class="string">    &lt;/property&gt;</span></span><br><span class="line"><span class="string">&lt;/bean&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-6-什么是-spring-装配？"><a href="#3-6-什么是-spring-装配？" class="headerlink" title="3.6 什么是 spring 装配？"></a>3.6 什么是 spring 装配？</h3><p>当 bean 在 Spring 容器中组合在一起时，它被称为装配或 bean 装配。Spring 容器需要知道需要什么 bean 以及容器应该如何使用依赖注入来将 bean 绑定在一起，同时装配 bean。</p>
<h3 id="3-7-自动装配有哪些方式？"><a href="#3-7-自动装配有哪些方式？" class="headerlink" title="3.7 自动装配有哪些方式？"></a>3.7 自动装配有哪些方式？</h3><p>Spring 容器能够自动装配 bean。也就是说，可以通过检查 BeanFactory 的内容让 Spring 自动解析 bean 的协作者。</p>
<p>自动装配的不同模式：</p>
<ul>
<li>no - 这是默认设置，表示没有自动装配。应使用显式 bean 引用进行装配。</li>
<li>byName - 它根据 bean 的名称注入对象依赖项。它匹配并装配其属性与 XML 文件中由相同名称定义的 bean。</li>
<li>byType - 它根据类型注入对象依赖项。如果属性的类型与 XML 文件中的一个 bean 名称匹配，则匹配并装配属性。</li>
<li>构造函数 - 它通过调用类的构造函数来注入依赖项。它有大量的参数。</li>
<li>autodetect - 首先容器尝试通过构造函数使用 autowire 装配，如果不能，则尝试通过 byType 自动装配。</li>
</ul>
<h3 id="3-8-自动装配有什么局限？"><a href="#3-8-自动装配有什么局限？" class="headerlink" title="3.8 自动装配有什么局限？"></a>3.8 自动装配有什么局限？</h3><ul>
<li>覆盖的可能性 - 您始终可以使用<constructor-arg> 和 <property>设置指定依赖项，这将覆盖自动装配。</li>
<li>基本元数据类型 - 简单属性（如原数据类型，字符串和类）无法自动装配。</li>
<li>令人困惑的性质 - 总是喜欢使用明确的装配，因为自动装配不太精确。</li>
</ul>
<h2 id="4-注解"><a href="#4-注解" class="headerlink" title="4 注解"></a>4 注解</h2><h3 id="4-1-你用过哪些重要的-Spring-注解？"><a href="#4-1-你用过哪些重要的-Spring-注解？" class="headerlink" title="4.1 你用过哪些重要的 Spring 注解？"></a>4.1 你用过哪些重要的 Spring 注解？</h3><ul>
<li>@Controller - 用于 Spring MVC 项目中的控制器类。</li>
<li>@Service - 用于服务类。</li>
<li>@RequestMapping - 用于在控制器处理程序方法中配置 URI 映射。</li>
<li>@ResponseBody - 用于发送 Object 作为响应，通常用于发送 XML 或 JSON 数据作为响应。</li>
<li>@PathVariable - 用于将动态值从 URI 映射到处理程序方法参数。</li>
<li>@Autowired - 用于在 spring bean 中自动装配依赖项。</li>
<li>@Qualifier - 使用 @Autowired 注解，以避免在存在多个 bean 类型实例时出现混淆。</li>
<li>@Scope - 用于配置 spring bean 的范围。</li>
<li>@Configuration，@ComponentScan 和 @Bean - 用于基于 java 的配置。</li>
<li>@Aspect，@Before，@After，@Around，@Pointcut - 用于切面编程（AOP）。</li>
</ul>
<h3 id="4-2-如何在-spring-中启动注解装配？"><a href="#4-2-如何在-spring-中启动注解装配？" class="headerlink" title="4.2 如何在 spring 中启动注解装配？"></a>4.2 如何在 spring 中启动注解装配？</h3><p>默认情况下，Spring 容器中未打开注解装配。因此，要使用基于注解装配，我们必须通过配置&lt;context：annotation-config /&gt; 元素在 Spring 配置文件中启用它。</p>
<h3 id="4-3-Component-Controller-Repository-Service-有何区别？"><a href="#4-3-Component-Controller-Repository-Service-有何区别？" class="headerlink" title="4.3 @Component, @Controller, @Repository, @Service 有何区别？"></a>4.3 @Component, @Controller, @Repository, @Service 有何区别？</h3><ul>
<li>@Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</li>
<li>@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。</li>
<li>@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。</li>
<li>@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</li>
</ul>
<h3 id="4-4-Required-注解有什么用？"><a href="#4-4-Required-注解有什么用？" class="headerlink" title="4.4 @Required 注解有什么用？"></a>4.4 @Required 注解有什么用？</h3><p>@Required 应用于 bean 属性 setter 方法。此注解仅指示必须在配置时使用 bean 定义中的显式属性值或使用自动装配填充受影响的 bean 属性。如果尚未填充受影响的 bean 属性，则容器将抛出 BeanInitializationException。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Required</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> string <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-5-Autowired-注解有什么用？"><a href="#4-5-Autowired-注解有什么用？" class="headerlink" title="4.5 @Autowired 注解有什么用？"></a>4.5 @Autowired 注解有什么用？</h3><p>@Autowired 可以更准确地控制应该在何处以及如何进行自动装配。此注解用于在 setter 方法，构造函数，具有任意名称或多个参数的属性或方法上自动装配 bean。默认情况下，它是类型驱动的注入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> string <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-6-Qualifier-注解有什么用？"><a href="#4-6-Qualifier-注解有什么用？" class="headerlink" title="4.6 @Qualifier 注解有什么用？"></a>4.6 @Qualifier 注解有什么用？</h3><p>当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。</p>
<p>例如，这里我们分别有两个类，Employee 和 EmpAccount。在 EmpAccount 中，使用@Qualifier 指定了必须装配 id 为 emp1 的 bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EmpAccount.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmpAccount</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Employee emp;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(emp1)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(“Employee name : ”+emp.getName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-7-RequestMapping-注解有什么用？"><a href="#4-7-RequestMapping-注解有什么用？" class="headerlink" title="4.7 @RequestMapping 注解有什么用？"></a>4.7 @RequestMapping 注解有什么用？</h3><p>@RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类/方法。此注解可应用于两个级别：</p>
<ul>
<li>类级别：映射请求的 URL</li>
<li>方法级别：映射 URL 以及 HTTP 请求方法</li>
</ul>
<h2 id="5-数据访问"><a href="#5-数据访问" class="headerlink" title="5 数据访问"></a>5 数据访问</h2><h3 id="5-1-spring-DAO-有什么用？"><a href="#5-1-spring-DAO-有什么用？" class="headerlink" title="5.1 spring DAO 有什么用？"></a>5.1 spring DAO 有什么用？</h3><p>Spring DAO 使得 JDBC，Hibernate 或 JDO 这样的数据访问技术更容易以一种统一的方式工作。这使得用户容易在持久性技术之间切换。它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。</p>
<h3 id="5-2-列举-Spring-DAO-抛出的异常"><a href="#5-2-列举-Spring-DAO-抛出的异常" class="headerlink" title="5.2 列举 Spring DAO 抛出的异常"></a>5.2 列举 Spring DAO 抛出的异常</h3><p><img src="https://gitee.com/wisedu1/MyImage/raw/master/imgs/%E6%A1%86%E6%9E%B6/Spring%20DAO%20%E6%8A%9B%E5%87%BA%E7%9A%84%E5%BC%82%E5%B8%B8.png"></p>
<h3 id="5-3-spring-JDBC-API-中存在哪些类？"><a href="#5-3-spring-JDBC-API-中存在哪些类？" class="headerlink" title="5.3 spring JDBC API 中存在哪些类？"></a>5.3 spring JDBC API 中存在哪些类？</h3><ul>
<li>JdbcTemplate</li>
<li>SimpleJdbcTemplate</li>
<li>NamedParameterJdbcTemplate</li>
<li>SimpleJdbcInsert</li>
<li>SimpleJdbcCall</li>
</ul>
<h3 id="5-4-使用-Spring-访问-Hibernate-的方法有哪些？"><a href="#5-4-使用-Spring-访问-Hibernate-的方法有哪些？" class="headerlink" title="5.4 使用 Spring 访问 Hibernate 的方法有哪些？"></a>5.4 使用 Spring 访问 Hibernate 的方法有哪些？</h3><p>我们可以通过两种方式使用 Spring 访问 Hibernate：</p>
<ol>
<li>使用 Hibernate 模板和回调进行控制反转</li>
<li>扩展 HibernateDAOSupport 并应用 AOP 拦截器节点</li>
</ol>
<h3 id="5-5-列举-spring-支持的事务管理类型"><a href="#5-5-列举-spring-支持的事务管理类型" class="headerlink" title="5.5 列举 spring 支持的事务管理类型"></a>5.5 列举 spring 支持的事务管理类型</h3><p>Spring 支持两种类型的事务管理：</p>
<ol>
<li>程序化事务管理：在此过程中，在编程的帮助下管理事务。它为您提供极大的灵活性，但维护起来非常困难。</li>
<li>声明式事务管理：在此，事务管理与业务代码分离。仅使用注解或基于 XML 的配置来管理事务。</li>
</ol>
<h3 id="5-6-Spring-支持哪些-ORM-框架"><a href="#5-6-Spring-支持哪些-ORM-框架" class="headerlink" title="5.6 Spring 支持哪些 ORM 框架"></a>5.6 Spring 支持哪些 ORM 框架</h3><ul>
<li>Hibernate</li>
<li>iBatis</li>
<li>JPA</li>
<li>JDO</li>
<li>OJB</li>
</ul>
<h2 id="6-AOP"><a href="#6-AOP" class="headerlink" title="6 AOP"></a>6 AOP</h2><h3 id="6-1-什么是-AOP？"><a href="#6-1-什么是-AOP？" class="headerlink" title="6.1 什么是 AOP？"></a>6.1 什么是 AOP？</h3><p>AOP(Aspect-Oriented Programming), 即 面向切面编程, 它与 OOP( Object-Oriented Programming, 面向对象编程) 相辅相成, 提供了与 OOP 不同的抽象软件结构的视角.</p>
<p>在 OOP 中, 我们以类(class)作为我们的基本单元, 而 AOP 中的基本单元是 Aspect(切面)</p>
<h3 id="6-2-AOP-中的-Aspect、Advice、Pointcut、JointPoint-和-Advice-参数分别是什么？"><a href="#6-2-AOP-中的-Aspect、Advice、Pointcut、JointPoint-和-Advice-参数分别是什么？" class="headerlink" title="6.2 AOP 中的 Aspect、Advice、Pointcut、JointPoint 和 Advice 参数分别是什么？"></a>6.2 AOP 中的 Aspect、Advice、Pointcut、JointPoint 和 Advice 参数分别是什么？</h3><p><img src="https://gitee.com/wisedu1/MyImage/raw/master/imgs/%E6%A1%86%E6%9E%B6/AOP.png"></p>
<ol>
<li>Aspect - Aspect 是一个实现交叉问题的类，例如事务管理。方面可以是配置的普通类，然后在 Spring Bean 配置文件中配置，或者我们可以使用 Spring AspectJ 支持使用 @Aspect 注解将类声明为 Aspect。</li>
<li>Advice - Advice 是针对特定 JoinPoint 采取的操作。在编程方面，它们是在应用程序中达到具有匹配切入点的特定 JoinPoint 时执行的方法。您可以将 Advice 视为 Spring 拦截器（Interceptor）或 Servlet 过滤器（filter）。</li>
<li>Advice Arguments - 我们可以在 advice 方法中传递参数。我们可以在切入点中使用 args() 表达式来应用于与参数模式匹配的任何方法。如果我们使用它，那么我们需要在确定参数类型的 advice 方法中使用相同的名称。</li>
<li>Pointcut - Pointcut 是与 JoinPoint 匹配的正则表达式，用于确定是否需要执行 Advice。Pointcut 使用与 JoinPoint 匹配的不同类型的表达式。Spring 框架使用 AspectJ Pointcut 表达式语言来确定将应用通知方法的 JoinPoint。</li>
<li>JoinPoint - JoinPoint 是应用程序中的特定点，例如方法执行，异常处理，更改对象变量值等。在 Spring AOP 中，JoinPoint 始终是方法的执行器。</li>
</ol>
<h3 id="6-3-什么是通知（Advice）？"><a href="#6-3-什么是通知（Advice）？" class="headerlink" title="6.3 什么是通知（Advice）？"></a>6.3 什么是通知（Advice）？</h3><p>特定 JoinPoint 处的 Aspect 所采取的动作称为 Advice。Spring AOP 使用一个 Advice 作为拦截器，在 JoinPoint “周围”维护一系列的拦截器。</p>
<h3 id="6-4-有哪些类型的通知（Advice）？"><a href="#6-4-有哪些类型的通知（Advice）？" class="headerlink" title="6.4 有哪些类型的通知（Advice）？"></a>6.4 有哪些类型的通知（Advice）？</h3><ul>
<li>Before - 这些类型的 Advice 在 joinpoint 方法之前执行，并使用 @Before 注解标记进行配置。</li>
<li>After Returning - 这些类型的 Advice 在连接点方法正常执行后执行，并使用@AfterReturning 注解标记进行配置。</li>
<li>After Throwing - 这些类型的 Advice 仅在 joinpoint 方法通过抛出异常退出并使用 @AfterThrowing 注解标记配置时执行。</li>
<li>After (finally) - 这些类型的 Advice 在连接点方法之后执行，无论方法退出是正常还是异常返回，并使用 @After 注解标记进行配置。</li>
<li>Around - 这些类型的 Advice 在连接点之前和之后执行，并使用 @Around 注解标记进行配置。</li>
</ul>
<h3 id="6-5-指出在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处"><a href="#6-5-指出在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处" class="headerlink" title="6.5 指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处"></a>6.5 指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处</h3><p>concern 是我们想要在应用程序的特定模块中定义的行为。它可以定义为我们想要实现的功能。</p>
<p>cross-cutting concern 是一个适用于整个应用的行为，这会影响整个应用程序。例如，日志记录，安全性和数据传输是应用程序几乎每个模块都需要关注的问题，因此它们是跨领域的问题。</p>
<h3 id="6-6-AOP-有哪些实现方式？"><a href="#6-6-AOP-有哪些实现方式？" class="headerlink" title="6.6 AOP 有哪些实现方式？"></a>6.6 AOP 有哪些实现方式？</h3><p>实现 AOP 的技术，主要分为两大类：</p>
<ul>
<li>静态代理 - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；</li>
<li>编译时编织（特殊编译器实现）</li>
<li>类加载时编织（特殊的类加载器实现）。</li>
<li>动态代理 - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。</li>
<li>JDK 动态代理</li>
<li>CGLIB</li>
</ul>
<h3 id="6-7-Spring-AOP-and-AspectJ-AOP-有什么区别？"><a href="#6-7-Spring-AOP-and-AspectJ-AOP-有什么区别？" class="headerlink" title="6.7 Spring AOP and AspectJ AOP 有什么区别？"></a>6.7 Spring AOP and AspectJ AOP 有什么区别？</h3><p>Spring AOP 基于动态代理方式实现；AspectJ 基于静态代理方式实现。</p>
<p>Spring AOP 仅支持方法级别的 PointCut；提供了完全的 AOP 支持，它还支持属性级别的 PointCut。</p>
<h3 id="6-8-如何理解-Spring-中的代理？"><a href="#6-8-如何理解-Spring-中的代理？" class="headerlink" title="6.8 如何理解 Spring 中的代理？"></a>6.8 如何理解 Spring 中的代理？</h3><p>将 Advice 应用于目标对象后创建的对象称为代理。在客户端对象的情况下，目标对象和代理对象是相同的。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Advice + Target Object = Proxy</span><br></pre></td></tr></table></figure>

<h3 id="6-9-什么是编织（Weaving）？"><a href="#6-9-什么是编织（Weaving）？" class="headerlink" title="6.9 什么是编织（Weaving）？"></a>6.9 什么是编织（Weaving）？</h3><p>为了创建一个 advice 对象而链接一个 aspect 和其它应用类型或对象，称为编织（Weaving）。在 Spring AOP 中，编织在运行时执行。请参考下图：</p>
<p><img src="https://gitee.com/wisedu1/MyImage/raw/master/imgs/%E6%A1%86%E6%9E%B6/weaving.png"></p>
<h2 id="7-MVC"><a href="#7-MVC" class="headerlink" title="7 MVC"></a>7 MVC</h2><h3 id="7-1-Spring-MVC-框架有什么用？"><a href="#7-1-Spring-MVC-框架有什么用？" class="headerlink" title="7.1 Spring MVC 框架有什么用？"></a>7.1 Spring MVC 框架有什么用？</h3><p>Spring Web MVC 框架提供 模型-视图-控制器 架构和随时可用的组件，用于开发灵活且松散耦合的 Web 应用程序。MVC 模式有助于分离应用程序的不同方面，如输入逻辑，业务逻辑和 UI 逻辑，同时在所有这些元素之间提供松散耦合。</p>
<h3 id="7-2-描述一下-DispatcherServlet-的工作流程"><a href="#7-2-描述一下-DispatcherServlet-的工作流程" class="headerlink" title="7.2 描述一下 DispatcherServlet 的工作流程"></a>7.2 描述一下 DispatcherServlet 的工作流程</h3><p>DispatcherServlet 的工作流程可以用一幅图来说明：</p>
<p><img src="https://gitee.com/wisedu1/MyImage/raw/master/imgs/%E6%A1%86%E6%9E%B6/DispatcherServlet%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png"></p>
<ol>
<li>向服务器发送 HTTP 请求，请求被前端控制器 DispatcherServlet 捕获。</li>
<li>DispatcherServlet 根据 -servlet.xml 中的配置对请求的 URL 进行解析，得到请求资源标识符（URI）。然后根据该 URI，调用 HandlerMapping 获得该 Handler 配置的所有相关的对象（包括 Handler 对象以及 Handler 对象对应的拦截器），最后以HandlerExecutionChain 对象的形式返回。</li>
<li>DispatcherServlet 根据获得的Handler，选择一个合适的 HandlerAdapter。（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的 preHandler(…)方法）。</li>
<li>提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。在填充Handler的入参过程中，根据你的配置，Spring 将帮你做一些额外的工作：</li>
</ol>
<ul>
<li>HttpMessageConveter：将请求消息（如 Json、xml 等数据）转换成一个对象，将对象转换为指定的响应信息。</li>
<li>数据转换：对请求消息进行数据转换。如<code>String</code>转换成<code>Integer</code>、<code>Double</code>等。</li>
<li>数据根式化：对请求消息进行数据格式化。如将字符串转换成格式化数字或格式化日期等。</li>
<li>数据验证：验证数据的有效性（长度、格式等），验证结果存储到<code>BindingResult</code>或<code>Error</code>中。</li>
</ul>
<ol start="5">
<li><p>Handler(Controller)执行完成后，向 DispatcherServlet 返回一个 ModelAndView 对象；</p>
</li>
<li><p>根据返回的ModelAndView，选择一个适合的 ViewResolver（必须是已经注册到 Spring 容器中的ViewResolver)返回给DispatcherServlet。</p>
</li>
<li><p>ViewResolver 结合Model和View，来渲染视图。</p>
</li>
<li><p>视图负责将渲染结果返回给客户端。</p>
</li>
</ol>
<h3 id="7-3-介绍一下-WebApplicationContext"><a href="#7-3-介绍一下-WebApplicationContext" class="headerlink" title="7.3 介绍一下 WebApplicationContext"></a>7.3 介绍一下 WebApplicationContext</h3><p>WebApplicationContext 是 ApplicationContext 的扩展。它具有 Web 应用程序所需的一些额外功能。它与普通的 ApplicationContext 在解析主题和决定与哪个 servlet 关联的能力方面有所不同。</p>
<h2 id="8-参考资料"><a href="#8-参考资料" class="headerlink" title="8 参考资料"></a>8 参考资料</h2><ol>
<li><p>作者 | 静默虚空 </p>
<p>链接 | <a href="https://juejin.cn/post/6844903828567883789">https://juejin.cn/post/6844903828567883789</a></p>
</li>
</ol>
<hr>
<p>部分内容来源于网络，作为学习使用，如有侵权请联系我删除。请注明来意。</p>
<p>邮箱：<a href="mailto:&#x77;&#x69;&#x73;&#101;&#100;&#x75;&#49;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;">&#x77;&#x69;&#x73;&#101;&#100;&#x75;&#49;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;</a></p>
<p>微信：</p>
<img src="https://gitee.com/wisedu1/MyImage/raw/master/imgs/%E6%9C%AC%E4%BA%BA%E7%9A%84%E5%BE%AE%E4%BF%A1%E4%BA%8C%E7%BB%B4%E7%A0%81/%E4%B8%AA%E4%BA%BA%E5%BE%AE%E4%BF%A1%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg" width="200px" />

]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 常见难点</title>
    <url>/2021/04/29/Java%20%E5%B8%B8%E8%A7%81%E9%9A%BE%E7%82%B9/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="Java-常见难点"><a href="#Java-常见难点" class="headerlink" title="Java 常见难点"></a>Java 常见难点</h1><h2 id="1-java-基础"><a href="#1-java-基础" class="headerlink" title="1 java 基础"></a>1 java 基础</h2><h3 id="1-1-容器"><a href="#1-1-容器" class="headerlink" title="1.1 容器"></a>1.1 容器</h3><h4 id="1-1-1-LinkedList-和-ArrayList"><a href="#1-1-1-LinkedList-和-ArrayList" class="headerlink" title="1.1.1 LinkedList 和 ArrayList"></a>1.1.1 LinkedList 和 ArrayList</h4><ol>
<li><p>数据结构不同</p>
<ul>
<li>ArrayList <font color ="red">（好查找）</font>是数组的数据结构。</li>
<li>LinkedList <font color="red">（好修改）</font>是链表的数据结构。</li>
</ul>
</li>
<li><p>效率不同</p>
<p>当随机访问 List（ get 和 set 操作）时，ArrayList 比 LinkedList 的效率更高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</p>
<p>当对数据进行增加和删除的操作( add 和 remove 操作)时，LinkedList 比 ArrayList  的效率更高，因为 ArrayList 是数组，所以在其中进行增删操作时，会对操作点之后所有数据的下标索引造成影响，需要进行数据的移动。</p>
</li>
<li><p>自由性不同</p>
<p>ArrayList 自由性较低，因为它需要<strong>手动</strong>的设置固定大小的容量，但是它的使用比较方便，只需要创建，然后添加数据，通过调用下标进行使用；而 LinkedList 自由性较高，能够动态的随数据量的变化而变化，但是它不便于使用。</p>
</li>
<li><p>主要控件开销不同</p>
<p>ArrayList 主要控件开销在于需要在给 ArrayList 列表预留一定空间；而 LinkedList 主要控件开销在于需要存储结点信息以及结点指针信息。</p>
</li>
<li><p>ArrayList 和 LinkedList 的线程安全问题</p>
<p>都不安全，不然不然 JUC 不会实现 CopyOnWriteArrayList 和 ConcurrentLinkedQueue。</p>
<blockquote>
<p>JUC: java.util.concurrent</p>
</blockquote>
</li>
</ol>
<h4 id="1-1-2-HashMap"><a href="#1-1-2-HashMap" class="headerlink" title="1.1.2 HashMap"></a>1.1.2 HashMap</h4><ol>
<li><p>HashMap 的数据结构</p>
<p>哈希结构表：数组+链表</p>
<ul>
<li><p><font color="red">通过哈希表结构配合对象的 hashCode 和 equals 方法就可以保证键的唯一性</font></p>
<blockquote>
<p>建议今后存储自定义类型的时候，重写hashCode和equals方法。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>HashMap 和 HashTable 以及 concurrentHashmap 的区别</p>
<ul>
<li><p>HashMap（不同步，<strong>线程不安全</strong>）允许存储null键和null值；</p>
</li>
<li><p>Hashtable 不允许存储 null 键和 null 值（同步，<strong>线程安全</strong>，<strong>效率低</strong>）。</p>
<blockquote>
<p>如果在多线程的场景下，也无需使用 Hashtable 集合，我们可以使用 <strong>ConcurrenntHashMap</strong> 集合，这是一个线程同步的。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>HashMap resize()</p>
<ul>
<li><p>两个重要参数：</p>
<ul>
<li><p><strong>初始容量</strong></p>
<p>默认 16</p>
<p>哈希表中桶的数量</p>
</li>
<li><p><strong>负载因子</strong></p>
<p>默认 0.75</p>
<p>哈希表扩容的阈值</p>
</li>
</ul>
</li>
<li><p>HashMap 的扩容</p>
<ul>
<li>当达到阈值时，自动扩容。</li>
<li>扩容后的数组为原数组的<strong>两倍</strong>，并且数组的大小是 <strong>2 的次幂</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p>Collection 与 Collections 的根本区别</p>
<ul>
<li>Collection 是一个<strong>集合接口</strong>。它提供了对集合对象进行基本操作的通用接口方法。Collection 接口在 Java 类库中有很多具体的实现。Collection 接口的意义是为各种具体的集合提供了最大化的统一操作方式。</li>
<li>Collections 是一个<strong>包装类</strong>。它包含有各种有关集合操作的<strong>静态多态</strong>方法。此类<strong>不能实例化</strong>，就像一个工具类，服务于Java的 Collection 框架。</li>
</ul>
</li>
</ol>
<h4 id="1-1-3-HashCode-和-equals"><a href="#1-1-3-HashCode-和-equals" class="headerlink" title="1.1.3 HashCode() 和 equals()"></a>1.1.3 HashCode() 和 equals()</h4><ol>
<li>它们都是 Object 类中的方法<ul>
<li>如果类不重写这两个方法：<ul>
<li>hashCode():属于是本地方法，返回的是对象的地址值。</li>
<li>equals():用来比较两个对象的地址值是否相等。</li>
</ul>
</li>
<li>如果重写这两个方法：<ul>
<li>hashCode(): 返回的是根据对象的成员变量，计算出的一个整数。</li>
<li>equals(): 比较的是两个对象中成员信息是否相等。</li>
</ul>
</li>
</ul>
</li>
<li>类中重写 hashCode() 和 equals() 比较两个对象是否相等<ul>
<li>两个对象通过 equals() 比较是相等的，那 hashCode() 肯定是相等，也就是 equals() 是绝对可靠的。</li>
<li>两个对象通过 hashCode 比较相等，但是equals去做比较不一定相等，也就是 hashCode 不是绝对可靠的。</li>
</ul>
</li>
<li>通过 hashCode 和 equals 搭配使用提高判断相等效率<ul>
<li>由于对于一个对象有大量的成员信息，用 equals 比较会降低效率，所以可以先通过 hashCode 进行比较，如果不相等则两个对象一定不同，如果相同再用 equals 比较，这样可以调高效率。</li>
</ul>
</li>
</ol>
<h4 id="1-1-4-HashSet"><a href="#1-1-4-HashSet" class="headerlink" title="1.1.4 HashSet"></a>1.1.4 HashSet</h4><ol>
<li><p>HashSet 集合特点无序，元素唯一在 HashSet 集合中，通过  hashCode() 和 equals()，保证了元素的唯一性。</p>
<p>这个判断的流程是：</p>
<ul>
<li>首先比较对象的哈希值是否相同，这个哈希值是根据对象的 hashCode() 计算出来的；</li>
<li>如果哈希值不同，就直接添加到集合中；</li>
<li>如果哈希值相同，继续执行 equals() 进行比较；</li>
<li>返回的是 true，说明元素重复，不添加；</li>
<li>返回的是 false，说明元素不重复，就添加。</li>
</ul>
</li>
</ol>
<h2 id="2-线程和锁"><a href="#2-线程和锁" class="headerlink" title="2 线程和锁"></a>2 线程和锁</h2><h3 id="2-1-线程的状态"><a href="#2-1-线程的状态" class="headerlink" title="2.1 线程的状态"></a>2.1 线程的状态</h3><table>
<thead>
<tr>
<th align="center">状态名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">NEW</td>
<td align="center">初始状态，线程被构建，但没调用 start() 方法</td>
</tr>
<tr>
<td align="center">RUNNABLE</td>
<td align="center">运行状态，Java 线程将操作系统中的就绪和运行两种状态笼统地称作“运行中”</td>
</tr>
<tr>
<td align="center">BLOCKED</td>
<td align="center">阻塞状态，表示线程阻塞于锁</td>
</tr>
<tr>
<td align="center">WAITING</td>
<td align="center">等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断）</td>
</tr>
<tr>
<td align="center">TIME_WAITING</td>
<td align="center">超时等待状态，该状态不同于 WAITING，它是可以在指定的时间自行返回的</td>
</tr>
<tr>
<td align="center">TERMINATED</td>
<td align="center">终止状态，表示当前线程已经执行完毕</td>
</tr>
</tbody></table>
<h3 id="2-2-创建线程的方式"><a href="#2-2-创建线程的方式" class="headerlink" title="2.2 创建线程的方式"></a>2.2 创建线程的方式</h3><h4 id="2-2-1-继承-Thread-类"><a href="#2-2-1-继承-Thread-类" class="headerlink" title="2.2.1 继承 Thread 类"></a>2.2.1 继承 Thread 类</h4><p>​    Thread类本质上是实现了Runnable接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过Thread类的start()实例方法。start()方法是一个native方法，它将启动一个新线程，并执行run()方法。这种方式实现多线程很简单，通过自己创建的类型直接extend Thread，并复写run()方法，就可以启动新线程并执行自己定义的run()方法。</p>
<p><strong>优点：</strong>代码简单</p>
<p><strong>缺点：</strong>该类无法继承别的类</p>
<h4 id="2-2-2-实现-Runnable-接口"><a href="#2-2-2-实现-Runnable-接口" class="headerlink" title="2.2.2 实现 Runnable 接口"></a>2.2.2 实现 Runnable 接口</h4><p>java中的类属于单继承（防止菱形继承），如果自己的类以及extends另一个类，就无法直接extends Thread， 但是一个类继承一个类同时，是可以实现多个接口的。</p>
<p><strong>优点：</strong>继承其他类。统一实现该接口的实例可以共享资源。</p>
<p><strong>缺点：</strong>代码复杂</p>
<h4 id="2-2-3-实现-callable-接口"><a href="#2-2-3-实现-callable-接口" class="headerlink" title="2.2.3 实现 callable 接口"></a>2.2.3 实现 callable 接口</h4><p>实现Runnable和实现Callable接口的方式基本相同，不过<strong>Callable接口中的call()方法有返回值，Runnable接口中的run()方法无返回值</strong></p>
<h4 id="2-3-4-线程池方式"><a href="#2-3-4-线程池方式" class="headerlink" title="2.3.4 线程池方式"></a>2.3.4 线程池方式</h4><ul>
<li><p><strong>corePoolSize（核心线程数）</strong></p>
<p>（1）核心线程会一直存在，即使没有任务执行； </p>
<p>（2）当线程数小于核心线程数的时候，即使有空闲线程，也会一直创建线程直到达到核心线程数；</p>
<p>（3）设置allowCoreThreadTimeout=true（默认false）时，核心线程会超时关闭。</p>
</li>
<li><p><strong>queueCapacity（任务队列容量）</strong></p>
<p>也叫阻塞队列，当核心线程都在运行，此时再有任务进来，会进入任务队列，排队等待线程执行。</p>
</li>
<li><p><strong>maxPoolSize（最大线程数）</strong></p>
<p>(1）线程池里允许存在的最大线程数量；<br>(2）当任务队列已满，且线程数量大于等于核心线程数时，会创建新的线程执行任务；<br>(3）线程池里允许存在的最大线程数量。当任务队列已满，且线程数量大于等于核心线程数时，会创建新的线程执行任务。</p>
</li>
<li><p><strong>keepAliveTime（线程空闲时间）</strong></p>
<p>(1）当线程空闲时间达到keepAliveTime时，线程会退出（关闭），直到线程数等于核心线程数；<br>(2）如果设置了allowCoreThreadTimeout=true，则线程会退出直到线程数等于零。</p>
</li>
<li><p><strong>allowCoreThreadTimeout（允许核心线程超时）</strong></p>
</li>
<li><p><strong>rejectedExecutionHandler（任务拒绝处理器）</strong></p>
<p>(1）当线程数量达到最大线程数，且任务队列已满时，会拒绝任务；<br>(2）调用线程池shutdown()方法后，会等待执行完线程池的任务之后，再shutdown()。如果在调用了shutdown()方法和线程池真正shutdown()之间提交任务，会拒绝新任务。</p>
</li>
<li><p><strong>线程池：</strong>本质上就是一个容纳多个线程的容器，其中的线程可以重复使用，省去了频繁创建线程对象的操作，因为反复创建线程是非常消耗资源的。</p>
</li>
</ul>
<h3 id="2-3-run-和-start-方法"><a href="#2-3-run-和-start-方法" class="headerlink" title="2.3 run() 和 start() 方法"></a>2.3 run() 和 start() 方法</h3><ul>
<li><p>start：</p>
<p>用start方法来<strong>启动线程</strong>，真正实现了多线程运行，这时无需等待run方法体代码执行完毕而直接继续执行下面的代码。通过调用Thread类的 start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行run()方法，这里方法 run()称为<strong>线程体</strong>，它包含了要执行的这个线程的内容，run方法运行结束，此线程随即终止。</p>
</li>
<li><p>run：</p>
<p>run()方法只是类的一个<strong>普通方法</strong>而已，如果直接调用run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run<strong>方法体</strong>执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。</p>
</li>
</ul>
<h3 id="2-4-ThreadLocal"><a href="#2-4-ThreadLocal" class="headerlink" title="2.4 ThreadLocal"></a>2.4 ThreadLocal</h3><p>通常情况下，我们创建的变量是可以被任何⼀个线程访问并修改的。<strong>如果想实现每⼀个线程都有 ⾃⼰的专属本地变量该如何解决呢？</strong> JDK 中提供的 ThreadLocal 类正是为了解决这样的问题。 <strong>ThreadLocal 类主要解决的就是让每个线程绑定⾃⼰的值，可以将 ThreadLocal 类形象的⽐喻成存放数据的盒⼦，盒⼦中可以存储每个线程的私有数据。</strong></p>
<p><strong>如果你创建了⼀个 ThreadLocal 变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是 ThreadLocal 变量名的由来。他们可以使⽤ get 和 set ⽅法来获取默认值或将其值更改为当前线程所存的副本的值，从⽽避免了线程安全问题。</strong></p>
<h4 id="2-4-1-Threadlocal-key-的弱引用"><a href="#2-4-1-Threadlocal-key-的弱引用" class="headerlink" title="2.4.1 Threadlocal key 的弱引用"></a>2.4.1 Threadlocal key 的弱引用</h4><p>方便垃圾回收。</p>
<h3 id="2-5-强、软、弱、引用"><a href="#2-5-强、软、弱、引用" class="headerlink" title="2.5 强、软、弱、引用"></a>2.5 强、软、弱、引用</h3><ul>
<li><p>强引用：</p>
<p>直接 <code>new</code></p>
</li>
<li><p>软引用：</p>
<p>通过<code>SoftReference</code>创建，在内存空间不足的时候直接销毁，即它可能最后的销毁地点是在老年区</p>
</li>
<li><p>弱引用：</p>
<p>通过<code>WeakReference</code>创建，在<code>GC</code>的时候直接销毁。即其销毁地点必定为伊甸区</p>
</li>
<li><p>虚引用：</p>
<p>通过<code>PhantomReference </code>创建，它和不存也一样，<strong>「非常虚，只能通过引用队列在进行一些操作，主要用于堆外内存回收」</strong></p>
</li>
</ul>
<h3 id="2-6-synchronized-四种锁状态的升级"><a href="#2-6-synchronized-四种锁状态的升级" class="headerlink" title="2.6 synchronized 四种锁状态的升级"></a>2.6 synchronized 四种锁状态的升级</h3><p>在 Java 语言中，使用 Synchronized 是能够实现线程同步的，即<strong>加锁</strong>。并且实现的是<strong>悲观锁</strong>，在操作同步资源的时候直接先加锁。</p>
<p>加锁可以使一段代码在同一时间只有一个线程可以访问，在增加安全性的同时，牺牲掉的是程序的执行性能，所以为了在一定程度上减少获得锁和释放锁带来的性能消耗，在 jdk6 之后便引入了“偏向锁”和“轻量级锁”，所以总共有4种锁状态，级别由低到高依次为：<strong>无锁状态</strong>、<strong>偏向锁状态</strong>、<strong>轻量级锁状态</strong>、<strong>重量级锁状态</strong>。这几个状态会随着竞争情况逐渐升级。</p>
<p><strong>注意：锁可以升级但不能降级。</strong></p>
<ul>
<li><p><strong>无锁</strong></p>
<p>无锁是指没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p>
</li>
<li><p><strong>偏向锁</strong></p>
<p>偏向锁是指当一段同步代码一直被同一个线程所访问时，即不存在多个线程的竞争时，那么该线程在后续访问时便会自动获得锁，从而降低获取锁带来的消耗，即提高性能。</p>
</li>
<li><p><strong>轻量级锁</strong></p>
<p>轻量级锁是指当锁是偏向锁的时候，却被另外的线程所访问，此时偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，线程不会阻塞，从而提高性能。</p>
</li>
<li><p><strong>重量级锁</strong></p>
<p>重量级锁是指当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态。</p>
</li>
</ul>
<p><strong>自旋：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">引入自旋这一规则的原因其实也很简单，因为阻塞或唤醒一个 Java 线程需要操作系统切换 CPU 状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。并且在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，这部分操作的开销其实是得不偿失的。</span><br><span class="line"></span><br><span class="line">自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。</span><br></pre></td></tr></table></figure>

<h3 id="2-7-Lock-和-synchronized-底层原理及比较"><a href="#2-7-Lock-和-synchronized-底层原理及比较" class="headerlink" title="2.7 Lock 和 synchronized 底层原理及比较"></a>2.7 Lock 和 synchronized 底层原理及比较</h3><p><strong>两者完全不一样</strong>，<strong>synchronize基于JVM的锁，lock基于JDK</strong>。</p>
<ul>
<li><p><strong>synchronized</strong></p>
<p>synchronized 锁住的是普通对象或类对象</p>
</li>
<li><p><strong>lock</strong></p>
<p> lock 锁住的是 <strong>Lock 对象</strong></p>
</li>
</ul>
<h3 id="2-8-Lock接口与synchronized的比较"><a href="#2-8-Lock接口与synchronized的比较" class="headerlink" title="2.8  Lock接口与synchronized的比较"></a>2.8  Lock接口与synchronized的比较</h3><ol>
<li>synchronized是关键字，而Lock是一个接口。</li>
<li>synchronized会自动释放锁，而Lock必须手动释放锁。</li>
<li>synchronized是不可中断的，Lock可以中断也可以不中断。 </li>
<li>通过Lock可以知道线程有没有拿到锁，而synchronized不能。</li>
<li>synchronized能锁住方法和代码块，而Lock只能锁住代码块。</li>
<li>Lock可以使用读锁提高多线程读效率。 </li>
<li>synchronized是非公平锁，ReentrantLock可以控制是否是公平锁。</li>
</ol>
<h3 id="2-9-Lock接口比synchronized的优势"><a href="#2-9-Lock接口比synchronized的优势" class="headerlink" title="2.9 Lock接口比synchronized的优势"></a>2.9 Lock接口比synchronized的优势</h3><ol>
<li>能够显示地获取和释放锁，锁地运用更灵活</li>
<li>可以方便地实现公平锁</li>
</ol>
<p>但是，在大部分情况下，<strong>非公平锁是可提高效率的。</strong></p>
<h3 id="2-10-Java-内存模型"><a href="#2-10-Java-内存模型" class="headerlink" title="2.10 Java 内存模型"></a>2.10 Java 内存模型</h3><p>JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。从抽象的角度来看，JMM定义了<strong>线程</strong>和<strong>主内存</strong>之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。</p>
<h3 id="2-11-CAS-（解决原子性）-未完成"><a href="#2-11-CAS-（解决原子性）-未完成" class="headerlink" title="2.11 CAS （解决原子性）(未完成)"></a>2.11 CAS （解决原子性）(未完成)</h3><p>CAS,compare and swap的缩写，中文翻译成比较并交换。</p>
<p>在JDK 5之前Java语言是靠synchronized关键字保证<strong>同步</strong>的，这会导致有锁。</p>
<p>锁机制存在以下问题：</p>
<p>（1）在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。</p>
<p>（2）一个线程持有锁会导致其它所有需要此锁的线程挂起。</p>
<p>（3）如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。</p>
<h3 id="2-12-wait-方法-和-sleep-方法（未完成）"><a href="#2-12-wait-方法-和-sleep-方法（未完成）" class="headerlink" title="2.12 wait 方法 和 sleep 方法（未完成）"></a>2.12 wait 方法 和 sleep 方法（未完成）</h3><ul>
<li>wait和sleep的基本使用：<ul>
<li>wait：此方法来自Object类，必须由锁对象进行调用。</li>
<li>sleep：此方法来之Thread类，是Thread类的静态方法，可以类名点调用。</li>
</ul>
</li>
</ul>
<hr>
<p>部分内容来源于网络，作为学习使用，如有侵权请联系我删除。请注明来意。</p>
<p>邮箱：<a href="mailto:&#x77;&#x69;&#x73;&#101;&#100;&#x75;&#49;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#109;">&#x77;&#x69;&#x73;&#101;&#100;&#x75;&#49;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#109;</a></p>
<p>微信：</p>
<img src="https://gitee.com/wisedu1/MyImage/raw/master/imgs/%E6%9C%AC%E4%BA%BA%E7%9A%84%E5%BE%AE%E4%BF%A1%E4%BA%8C%E7%BB%B4%E7%A0%81/%E4%B8%AA%E4%BA%BA%E5%BE%AE%E4%BF%A1%E4%BA%8C%E7%BB%B4%E7%A0%811.jpg" width="200px" />

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java 常见难点</tag>
      </tags>
  </entry>
</search>
